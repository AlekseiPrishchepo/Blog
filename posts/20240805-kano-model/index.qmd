---
title: "Kano Method for Prioritization of Features"
author: "Aleksei"
date: "2024-08-05"
categories: [marketing, product]
drafd: true
image: "image.png"
---

# Kano Method for Prioritization of Features

The Kano model is a theory for product development and customer
satisfaction developed in the 1980s by Professor Noriaki Kano. The model
classifies customer preferences into five categories: Must-be Quality,
One-dimensional Quality, Attractive Quality, Indifferent Quality, and
Reverse Quality. The Kano model is used to prioritize features and
functionalities in product development based on customer needs and
expectations.

## Categories of the Kano Model

### Must-be Quality

Must-be Quality features are basic requirements that customers expect.
If these features are not present in a product, customers will be
dissatisfied. However, the presence of these features does not
necessarily lead to customer satisfaction. Must-be Quality features are
considered essential for the product.

> Examples: a car must have wheels, a smartphone must have a battery, a
> website must have a search function.

### One-dimensional Quality

One-dimensional Quality features are directly proportional to customer
satisfaction. The more these features are present in a product, the more
satisfied customers will be. These features are usually explicitly
stated by customers and are easy to measure and quantify.

> Examples: a car with leather seats, a smartphone with a
> high-resolution camera, a website with fast loading times.

### Attractive Quality

Attractive Quality features are unexpected features that delight
customers. These features are not explicitly requested by customers but
can create a positive emotional response when present. Attractive
Quality features can differentiate a product from its competitors and
create a competitive advantage.

> Examples: a car with a built-in navigation system, a smartphone with
> facial recognition technology, a website with personalized
> recommendations.

### Indifferent Quality

Indifferent Quality features are neither good nor bad from the
customer's perspective. Customers are indifferent to these features, and
their presence or absence does not significantly impact customer
satisfaction. These features are often considered "nice to have" but not
essential.

> Examples: a car with cup holders, a smartphone with a stylus, a
> website with social media integration.

### Reverse Quality

Reverse Quality features are features that, when present, can lead to
customer dissatisfaction. These features may be perceived as unnecessary
or even annoying by customers. It is essential to identify and eliminate
Reverse Quality features to prevent negative customer experiences.

> Examples: a car with uncomfortable seats, a smartphone with a short
> battery life, a website with intrusive pop-up ads.

## Prioritizing Features with the Kano Model

With the Kano model, prioritization of features and functionalities
becomes clear and straightforward as that:

**a)** keep eye on the Must-be Quality features, as they are essential,
**b)** incorporate One-dimensional Quality features to increase customer
satisfaction, **c)** consider Attractive Quality features to create a
competitive advantage; **d)** eliminate Reverse Quality features
completely, and **e)** save resources by setting Indifferent Quality
features as low priority.

## Implementation

Implementing the Kano model involves a sequence of steps, beginning with
the development of a questionnaire. For each feature, two types of
questions are posed: functional and dysfunctional.

-   The functional question assesses respondents' feelings when a
    feature is present.
-   The dysfunctional question gauges their reactions in the absence of
    that feature.

Each question offers five possible responses, from "I like it" to "I
dislike it." Subsequently, these responses are classified into the five
Kano categories.

```{python iterp}
# | echo: false
# | label: tbl-cap-margin
# | cap-location: top
# | tbl-cap: "Classification of answers to the Kano questionnaire."
# | tbl-cap-location: top
# |
import pandas as pd

interp = pd.read_csv("data/kano-interp.csv")

interp.groupby(["Functional", "Dysfunctional"]).agg({"Category": "first"}).unstack()
```

After the classification of responses, the next step is to calculate the
satisfaction and dissatisfaction scores for each feature. The
satisfaction influence score is calculated as the percentage of
Attractive and One-dimensional responses relative to the total number of
responses.

$$ \text{Satisfaction Influence} = \dfrac{A + O}{ A + O + M + I } \times 100 \% $$
The dissatisfaction influence score is calculated as the percentage of
One-dimensional and Must-be responses relative to the total number of
responses.

$$ \text{Dissatisfaction Influence} =  - \dfrac{O + M}{A + O + M + I} \times 100 \% $$
The features are then plotted on a Kano diagram, with the
dissatisfaction score on the x-axis and the satisfaction score on the
y-axis. The features are categorized based on their position in the
diagram: Attractive Quality features in the upper left quadrant,
One-dimensional Quality features in the upper right quadrant, Must-be
Quality features in the lower right quadrant, and Indifferent features
in the lower left quadrant.

```{python unnamed-chunk-1}
# | echo: false

import os
import pandas as pd


directory = "data"
files = [f for f in os.listdir(directory) if f.endswith("-clean.csv")]

df = pd.DataFrame()

for file in files:
    df = pd.concat([df, pd.read_csv(f"{directory}/{file}")])

df.tail()
```

```{python unnamed-chunk-2}
# | echo: false

# load features dictionary
features = pd.read_csv(f"data/features.csv")

# load answers dictionary
answers = pd.read_csv("data/answers.csv")
```

```{python unnamed-chunk-3}
# | echo: false
# | warning: false

# check if all variants of answers are present in dictionary

df1 = df[["F1_functional"]].dropna().drop_duplicates()
df1.columns = ["Answer"]

# df1.merge(answers, how="left", indicator=True).groupby("_merge").size()
```

```{python unnamed-chunk-4}
# | echo: false
import re


value_vars = [col for col in df.columns if re.findall(r"F\d+_", col)]
index_vars = [col for col in df.columns if col not in value_vars]

df_long = df.melt(
    id_vars=index_vars, value_vars=value_vars, var_name="Question", value_name="Answer"
)

df_long = df_long.dropna(subset=["Answer"])

# add code to answers
df_long = df_long.merge(answers[["Answer", "Code"]], how="left")

# extract type and id from question
df_long["Type"] = df_long["Question"].apply(lambda x: re.sub(r"F\d+_(.+)", "\\1", x))
df_long["Type"] = df_long["Type"].str.capitalize()

df_long["ID"] = df_long["Question"].apply(lambda x: re.sub(r"(F\d+_).+", "\\1", x))

# add columns for functional and dysfunctional codes
mask = df_long["Type"] == "Functional"
df_long.loc[mask, "FuncCode"] = df_long.loc[mask, "Code"]

mask = df_long["Type"] == "Dysfunctional"
df_long.loc[mask, "DysfCode"] = df_long.loc[mask, "Code"]
```

```{python unnamed-chunk-5}
# | echo: false

# group by columns and aggregate functional and dysfunctional codes
columns = ["ID", "Income_us", "Gender", "Age", "Employment", "Education"]
df_final = (
    df_long.fillna(0)
    .groupby(columns)
    .agg({"FuncCode": "sum", "DysfCode": "sum"})
    .reset_index()
)

# merge with features dictionary

df_final = df_final.merge(interp, on=["FuncCode", "DysfCode"], how="left")
```

```{python unnamed-chunk-6}
# | echo: false

# calculate satisfaction and dissatisfaction scores

df_final["Satisfaction"] = (df_final["Category"] == "Attractive") | (
    df_final["Category"] == "One-dimensional"
)
df_final["Dissatisfaction"] = (df_final["Category"] == "One-dimensional") | (
    df_final["Category"] == "Must-be"
)

df_final["Satisfaction"] = df_final["Satisfaction"].astype(int)
df_final["Dissatisfaction"] = df_final["Dissatisfaction"].astype(int)

df_results = (
    df_final.groupby("ID")
    .agg({"Satisfaction": "sum", "Dissatisfaction": "sum"})
    .reset_index()
)

df_results["SatisfactionInfluence"] = (
    df_results["Satisfaction"]
    / (df_results["Satisfaction"] + df_results["Dissatisfaction"])
    * 100
)

df_results["DissatisfactionInfluence"] = (
    -df_results["Dissatisfaction"]
    / (df_results["Satisfaction"] + df_results["Dissatisfaction"])
    * 100
)
```

```{python unnamed-chunk-7}
# | echo: false

# plot Kano diagram

import matplotlib.pyplot as plt
import seaborn as sns


plt.figure(figsize=(6, 6))

sns.scatterplot(
    data=df_results,
    x="DissatisfactionInfluence",
    y="SatisfactionInfluence",
    hue="ID",
    s=100,
)

plt.ylim(-100, 100)
plt.xlim(-100, 100)

plt.axhline(0, color="black", linestyle="--")
plt.axvline(0, color="black", linestyle="--")

plt.xlabel("Dissatisfaction Influence (%)")
plt.ylabel("Satisfaction Influence (%)")

plt.title("Kano Diagram")

plt.legend(title="Feature ID", bbox_to_anchor=(1.05, 1), loc="upper left")

plt.show()
plt.close()
```

## Application of the Kano Model

The Kano model can be applied in product development to prioritize
features and functionalities based on customer needs and expectations.
By categorizing features into the five Kano categories, product managers
can identify which features are essential, which are nice to have, and
which can create a competitive advantage.

The Kano model can also help product managers understand customer
preferences and make informed decisions about resource allocation and
product development. By focusing on Must-be Quality and One-dimensional
Quality features, product managers can ensure that the product meets
basic customer requirements and maximizes customer satisfaction.

In conclusion, the Kano model is a valuable tool for prioritizing
features and functionalities in product development. By understanding
customer preferences and categorizing features into the five Kano
categories, product managers can create products that meet customer
needs and expectations, leading to higher customer satisfaction and
competitive advantage.

